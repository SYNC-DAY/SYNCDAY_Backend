name: Deploy to AWS Elastic Beanstalk

on:
  push:
    branches: [ deploytest ]

jobs:
  deploy:
    runs-on: ubuntu-latest

    steps:
      # Checkout the code
      - uses: actions/checkout@v2

      # Set up JDK 17 for Gradle
      - name: Set up JDK 17
        uses: actions/setup-java@v2
        with:
          java-version: '17'
          distribution: 'temurin'

      # Install envsubst for environment variable substitution
      - name: Install envsubst
        run: sudo apt-get install -y gettext

      # Create Elastic Beanstalk configuration files
      - name: Create .ebextensions
        run: |
          mkdir -p .ebextensions
          cat > .ebextensions/01-docker-compose.config <<EOL
          files:
            "/etc/docker/config.json":
              mode: "000644"
              owner: root
              group: root
              content: |
                {
                  "mountpoints": {
                    "/var/app/current": {
                      "source": "/var/app/current",
                      "destination": "/var/app/current",
                      "type": "bind",
                      "readonly": false
                    }
                  }
                }
          EOL
          cat > .ebextensions/02-sysctl-settings.config <<EOL
          commands:
          00_create_elasticsearch_user:
            command: |
              if ! getent group elasticsearch > /dev/null; then
                groupadd -g 1000 elasticsearch
              fi
              if ! getent passwd elasticsearch > /dev/null; then
                useradd -u 1000 -g elasticsearch elasticsearch
              fi
          01_create_directories:
            command: |
              mkdir -p /var/app/current/es_data
              mkdir -p /var/app/current/es_logs
              mkdir -p /var/app/current/config/elasticsearch/indices
          
              chown -R elasticsearch:elasticsearch /var/app/current/es_data
              chown -R elasticsearch:elasticsearch /var/app/current/es_logs
              chown -R elasticsearch:elasticsearch /var/app/current/config/elasticsearch
          
              chmod -R 755 /usr/share/elasticsearch
              chmod 775 /var/app/current/es_data
              chmod 755 /var/app/current/es_logs
          
              mkdir -p /usr/share/elasticsearch
              chown -R elasticsearch:elasticsearch /usr/share/elasticsearch
              chmod 755 /usr/share/elasticsearch
          02_increase_vm_max_map_count:
            command: |
              echo "vm.max_map_count=262144" >> /etc/sysctl.conf
              sysctl -w vm.max_map_count=262144
          03_set_ulimits:
            command: |
              echo "elasticsearch soft nofile 65535" >> /etc/security/limits.conf
              echo "elasticsearch hard nofile 65535" >> /etc/security/limits.conf
              echo "elasticsearch soft memlock unlimited" >> /etc/security/limits.conf
              echo "elasticsearch hard memlock unlimited" >> /etc/security/limits.conf
          EOL

      - name: Create Elasticsearch configuration
        run: |
          # 필요한 디렉토리 구조 생성
          mkdir -p config/elasticsearch/indices
          
          cat > config/elasticsearch/elasticsearch.yml <<EOL
          cluster.name: "syncday-cluster"
          node.name: "syncday-node"
          network.host: 0.0.0.0
          discovery.type: single-node
          
          path.data: /usr/share/elasticsearch/data
          path.logs: /usr/share/elasticsearch/logs
          
          xpack.security.enabled: false
          EOL
          
          cat > config/elasticsearch/healthcheck.sh <<EOL
          #!/bin/bash
          curl -f "http://localhost:9200/_cat/health" || exit 1
          EOL
          chmod +x config/elasticsearch/healthcheck.sh
          
          # init-index.sh 파일 생성 - 초기 인덱스 설정 스크립트
          cat > config/elasticsearch/init-index.sh <<EOL
          #!/bin/bash
          set -e
          
          until curl -s http://localhost:9200 > /dev/null; do
              echo 'Waiting for Elasticsearch...'
              sleep 3
          done
          
          until curl -s http://localhost:9200/_cluster/health | grep -q '"status":"green"'; do
              echo 'Waiting for cluster to be ready...'
              sleep 3
          done
          
          echo "Cluster is ready. Starting index initialization..."
          
          echo "Deleting existing indices..."
          curl -X DELETE "localhost:9200/user_search,project_search,workspace_search,cardboard_search,card_search,attachment_search,comment_search"
          
          create_index() {
              local index_name=\$1
              echo "Creating \${index_name} index..."
              if curl -X PUT "localhost:9200/\${index_name}" -H 'Content-Type: application/json' -d "@/usr/share/elasticsearch/config/indices/\${index_name}.json"; then
                  echo "\${index_name} created successfully"
              else
                  echo "Failed to create \${index_name}"
                  exit 1
              fi
          }
          
          create_index "user_search"
          create_index "project_search"
          create_index "workspace_search"
          create_index "cardboard_search"
          create_index "card_search"
          create_index "attachment_search"
          create_index "comment_search"
          
          echo "All indices created successfully!"
          echo "Created indices:"
          curl 'http://localhost:9200/_cat/indices?v'
          EOL
          chmod +x config/elasticsearch/init-index.sh

      # Create application.yml for Spring Boot
      - name: Create application.yml
        run: |
          mkdir -p src/main/resources
          cat > src/main/resources/application.yml <<EOL
          server:
            port: 5000
  
          spring:
            application:
              name: syncday-service
  
            devtools:
              restart:
                enabled: false
              livereload:
                enabled: false
  
            mail:
              host: smtp.gmail.com
              port: 587
              username: ${MAIL_USERNAME}
              password: ${MAIL_PASSWORD}
              properties:
                mail.smtp.debug: true
                mail.smtp.connectiontimeout: 1000
                mail.starttls.enable: true
                mail.smtp.auth: true
  
            web:
              resources:
                add-mappings: false
  
            datasource:
              driver-class-name: org.mariadb.jdbc.Driver
              url: jdbc:mariadb://${RDS_HOSTNAME}:${RDS_PORT}/${RDS_DB_NAME}
              username: ${RDS_USERNAME}
              password: ${RDS_PASSWORD}
  
            jpa:
              database: mysql
              database-platform: org.hibernate.dialect.MariaDBDialect
              show-sql: false
              generate-ddl: false
  
              hibernate:
                ddl-auto: validate
                naming:
                  physical-strategy: org.hibernate.boot.model.naming.PhysicalNamingStrategyStandardImpl
              properties:
                hibernate:
                  format_sql: false
                  jdbc:
                    batch_size: 50
                  order_inserts: true
                  order_updates: true
                  cache:
                    use_second_level_cache: false
  
            data:
              redis:
                host: redis
                port: 6379
              mongodb:
                uri: mongodb://mongodb:27017/chatdb
              elasticsearch:
                repositories:
                  enabled: true
                uris: http://syncday-elasticsearch:9200
                connection-timeout: 5s
                socket-timeout: 3s
  
  
            task:
              execution:
                pool:
                  core-size: 8
                  max-size: 16
                  queue-capacity: 100
                thread-name-prefix: github-async
  
            # 캐시 설정 추가
            cache:
              type: redis
              redis:
                time-to-live: 3600000
                cache-null-values: false
  
          logging:
            level:
              com:
                threeping:
                  syncday: DEBUG
  
          
          springdoc:
            swagger-ui:
              path: /swagger-custom-ui.html
              groups-order: DESC
              tags-sorter: alpha
              operations-sorter: method
              disable-swagger-default-url: true
              display-request-duration: true
            show-actuator: true
            default-consumes-media-type: application/json
            default-produces-media-type: application/json
  
          token:
            access-expiration-time: 3600000
            refresh-expiration-time: 86400000
            secret: ${JWT_SECRET}
  
          github:
            app:
              id: ${APP_ID}
              private-key: "${APP_PRIVATE_KEY}"
               
            webhook:
              secret: ${WEBHOOK_SECRET}
            oauth2:
              client-id: ${OAUTH_CLIENT_ID}
              client-secret: ${OAUTH_CLIENT_SECRET}
            api:
              rate-limit:
                requests-per-hour: 5000
                core-pool-size: 5
                max-pool-size: 10
          EOL
        env:
          MAIL_USERNAME: ${{ secrets.MAIL_USERNAME }}
          MAIL_PASSWORD: ${{ secrets.MAIL_PASSWORD }}
          RDS_HOSTNAME: ${{ secrets.RDS_HOSTNAME }}
          RDS_PORT: ${{ secrets.RDS_PORT }}
          RDS_DB_NAME: ${{ secrets.RDS_DB_NAME }}
          RDS_USERNAME: ${{ secrets.RDS_USERNAME }}
          RDS_PASSWORD: ${{ secrets.RDS_PASSWORD }}
          JWT_SECRET: ${{ secrets.JWT_SECRET }}
          OAUTH_CLIENT_ID: ${{ secrets.OAUTH_CLIENT_ID }}
          OAUTH_CLIENT_SECRET: ${{ secrets.OAUTH_CLIENT_SECRET }}
          WEBHOOK_SECRET: ${{ secrets.WEBHOOK_SECRET }}
          APP_ID: ${{ secrets.APP_ID }}
          APP_PRIVATE_KEY: ${{ secrets.APP_PRIVATE_KEY }}

      - name: Create docker-compose.yml
        run: |
          cat > docker-compose.yml <<EOF
          services:
            elasticsearch:
              build:
                context: .
                dockerfile: Dockerfile.elasticsearch
              container_name: syncday-elasticsearch
              environment:
                - discovery.type=single-node
                - xpack.security.enabled=false
                - ES_JAVA_OPTS=-Xms512m -Xmx512m -Xlog:gc*=info:stderr
                - bootstrap.memory_lock=true
                - node.max_local_storage_nodes=10
              volumes:
                - /var/app/current/es_data:/usr/share/elasticsearch/data:rw
                - /var/app/current/es_logs:/usr/share/elasticsearch/logs:rw
              ulimits:
                memlock:
                  soft: -1
                  hard: -1
                nofile:
                  soft: 65536
                  hard: 65536
              ports:
                - "9200:9200"
              networks:
                - es-network
              privileged: true
              healthcheck:
                test: ["CMD-SHELL", "/usr/share/elasticsearch/healthcheck.sh"]
                interval: 30s
                timeout: 30s
                retries: 3
                start_period: 60s
            app:
              build: .
              container_name: syncday
              ports:
                - "5000:5000"
              environment:
                SPRING_PROFILES_ACTIVE: "prod"
                SPRING_DATASOURCE_URL: "jdbc:mariadb://${RDS_HOSTNAME}:${RDS_PORT}/${RDS_DB_NAME}"
                SPRING_DATASOURCE_USERNAME: "${RDS_USERNAME}"
                SPRING_DATASOURCE_PASSWORD: "${RDS_PASSWORD}"
                SPRING_DATA_MONGODB_URI: "mongodb://mongodb:27017/chatdb"
                SPRING_DATA_REDIS_HOST: "redis"
                SPRING_ELASTICSEARCH_URIS: "http://syncday-elasticsearch:9200"
                SPRING_MAIL_USERNAME: "${MAIL_USERNAME}"
                SPRING_MAIL_PASSWORD: "${MAIL_PASSWORD}"
                TOKEN_SECRET: "${JWT_SECRET}"
                GITHUB_APP_ID: "${APP_ID}"
                GITHUB_APP_PRIVATE_KEY: "${APP_PRIVATE_KEY}"
                GITHUB_WEBHOOK_SECRET: "${WEBHOOK_SECRET}"
                GITHUB_OAUTH2_CLIENT_ID: "${OAUTH_CLIENT_ID}"
                GITHUB_OAUTH2_CLIENT_SECRET: "${OAUTH_CLIENT_SECRET}"
              volumes:
                - ./:/app
              depends_on:
                elasticsearch:
                  condition: service_healthy
                mongodb:
                  condition: service_healthy
                redis:
                  condition: service_healthy
              networks:
                - es-network 
          
          
            mongodb:
              image: mongo:latest
              volumes:
                - /var/app/current/mongodb_data:/data/db
              ports:
                - "27017:27017"
              networks:
                - es-network 
              healthcheck:
                test: ["CMD", "mongosh", "--eval", "db.adminCommand('ping')"]
                interval: 30s
                timeout: 10s
                retries: 3
                start_period: 40s
          
            redis:
              image: redis:latest
              command: redis-server --notify-keyspace-events Ex
              volumes:
                - /var/app/current/redis_data:/data
              ports:
                - "6379:6379"
              networks:
                - es-network
              healthcheck:
                test: ["CMD", "redis-cli", "ping"]
                interval: 30s
                timeout: 10s
                retries: 3
                start_period: 20s
          networks:
            es-network:
              driver: bridge
          volumes:
            es_data:
              driver: local
          EOF
        env:
          RDS_HOSTNAME: ${{ secrets.RDS_HOSTNAME }}
          RDS_PORT: ${{ secrets.RDS_PORT }}
          RDS_DB_NAME: ${{ secrets.RDS_DB_NAME }}
          RDS_USERNAME: ${{ secrets.RDS_USERNAME }}
          RDS_PASSWORD: ${{ secrets.RDS_PASSWORD }}
          MAIL_USERNAME: ${{ secrets.MAIL_USERNAME }}
          MAIL_PASSWORD: ${{ secrets.MAIL_PASSWORD }}
          JWT_SECRET: ${{ secrets.JWT_SECRET }}
          APP_ID: ${{ secrets.APP_ID }}
          APP_PRIVATE_KEY: ${{ secrets.APP_PRIVATE_KEY }}
          WEBHOOK_SECRET: ${{ secrets.WEBHOOK_SECRET }}
          OAUTH_CLIENT_ID: ${{ secrets.OAUTH_CLIENT_ID }}
          OAUTH_CLIENT_SECRET: ${{ secrets.OAUTH_CLIENT_SECRET }}


      # Validate Docker Compose file
      - name: Validate docker-compose.yml
        run: docker compose config

      # Build Spring Boot application with Gradle
      - name: Grant execute permission for gradlew
        run: chmod +x ./gradlew

      - name: Build with Gradle
        run: ./gradlew clean build -x test

      - name: Print working directory
        run: pwd

      - name: List build directory
        run: ls -la ./build/libs

      - name: Show Current Time
        run: echo "CurrentTime=${{steps.current-time.outputs.formattedTime}}"
        shell: bash

      - name: Generate deployment package
        run: |
          # 1. 배포 디렉토리 구조 생성
          mkdir -p deploy/.platform/nginx/conf.d
          mkdir -p deploy/.ebextensions
          
          # 2. nginx 설정을 위한 .ebextensions 파일 생성
          cat > deploy/.ebextensions/99-nginx-setup.config <<EOL
          commands:
            01_cleanup_nginx_conf:
              command: |
                rm -f /etc/nginx/conf.d/*.conf
                rm -f /etc/nginx/nginx.conf
              ignoreErrors: true
            02_create_healthd_conf:
              command: |
                mkdir -p /etc/nginx/conf.d/elasticbeanstalk/
                echo 'location /health { access_log off; return 200 "OK"; }' > /etc/nginx/conf.d/elasticbeanstalk/healthd.conf
              ignoreErrors: true
            03_setup_nginx:
              command: |
                cp -f /var/app/current/.platform/nginx/nginx.conf /etc/nginx/nginx.conf
                chmod 644 /etc/nginx/nginx.conf
                service nginx restart
              ignoreErrors: true
          EOL
          
          # 3. nginx 설정 파일 복사 (.platform 디렉토리로)
          cp .platform/nginx/nginx.conf deploy/.platform/nginx/
          
          # 4. 기존 .ebextensions 파일들 복사
          cp -r .ebextensions/* deploy/.ebextensions/
          
          # 5. JAR 파일과 다른 필요한 파일들 복사
          JAR_FILE=$(ls ./build/libs/*SNAPSHOT.jar | grep -v plain)
          if [ -n "$JAR_FILE" ]; then
            cp "$JAR_FILE" deploy/app.jar
          else
            echo "No executable JAR file found!"
            exit 1
          fi
          
          # 6. 기타 필요한 파일들 복사
          echo "web: java -jar app.jar" > deploy/Procfile
          cp Dockerfile deploy/
          cp Dockerfile.elasticsearch deploy/
          cp -r config deploy/
          cp docker-compose.yml deploy/
          
          # 7. 배포 패키지 생성
          cd deploy && zip -r deploy.zip .
          
          # 8. 패키지 내용 확인 (디버깅용)
          echo "Deployment package contents:"
          unzip -l deploy.zip

      # Deploy to Elastic Beanstalk
      - name: Deploy to AWS Elastic Beanstalk
        uses: einaregilsson/beanstalk-deploy@v21
        with:
          aws_access_key: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws_secret_key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          application_name: Syncday
          environment_name: Syncday-env
          version_label: "syncdayback-${{ github.sha }}-${{ steps.current-time.outputs.formattedTime }}"
          region: ap-northeast-2
          deployment_package: deploy/deploy.zip
          wait_for_environment_recovery: 300